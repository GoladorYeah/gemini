Directory structure:
‚îî‚îÄ‚îÄ pricerunner-parser/
    ‚îú‚îÄ‚îÄ config.yaml
    ‚îú‚îÄ‚îÄ go.mod
    ‚îú‚îÄ‚îÄ main.go
    ‚îî‚îÄ‚îÄ internal/
        ‚îú‚îÄ‚îÄ config/
        ‚îÇ   ‚îî‚îÄ‚îÄ config.go
        ‚îú‚îÄ‚îÄ downloader/
        ‚îÇ   ‚îî‚îÄ‚îÄ image.go
        ‚îú‚îÄ‚îÄ models/
        ‚îÇ   ‚îî‚îÄ‚îÄ product.go
        ‚îú‚îÄ‚îÄ parser/
        ‚îÇ   ‚îî‚îÄ‚îÄ parser.go
        ‚îî‚îÄ‚îÄ storage/
            ‚îú‚îÄ‚îÄ database.go
            ‚îú‚îÄ‚îÄ factory.go
            ‚îú‚îÄ‚îÄ json.go
            ‚îî‚îÄ‚îÄ storage.go

================================================
FILE: pricerunner-parser/config.yaml
================================================
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞ PriceRunner (—É—Å–∫–æ—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
parser:
  # URL –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
  base_url: "https://www.pricerunner.com/cl/1/Mobile-Phones"
  
  # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±—Ä–∞—É–∑–µ—Ä–∞
  browser:
    headless: true
    timeout: 20000  # –£–º–µ–Ω—å—à–µ–Ω–æ –¥–æ 20 —Å–µ–∫—É–Ω–¥
    viewport:
      width: 1920
      height: 1080
    user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  
  # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É—Å–∫–æ—Ä–µ–Ω–æ)
  parsing:
    max_pages: 5
    delay_between_requests: 500   # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 1000 –¥–æ 500ms
    scroll_delay: 200             # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 200 –¥–æ 150ms  
    max_scrolls: 20               # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 20 –¥–æ 15
    
  # –°–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  selectors:
    # –ö–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Å–ø–∏—Å–∫–∞
    product_cards: "a[data-discover='true'][href*='/pl/'][title]"
    
    # –¶–µ–Ω–∞ - –±–µ—Ä–µ—Ç—Å—è –≤—Ç–æ—Ä–æ–π span
    price: "span.pr-1fcg5be"
    price_current: "div.pr-1ymxntz div.pr-i5pc8s:nth-child(2) span.pr-1fcg5be"
    
    # –û–ø–∏—Å–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ - –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
    description: "div.EhfYw80fYG.pr-yp5co9-RichText"
    description_alt: "div[class*='RichText']"
    description_fallback: "div[class*='description'], section[class*='description']"
    
    # –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    main_image: "img.pr-xahiol"
    additional_images: "div.pr-rda78c button img"
    
    # –¢–∞–±–ª–∏—Ü—ã —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
    feature_tables: "div.pr-1omptzn-Table-root table.pr-1regpt0-Table-table"
    
    # –ù–∞–≤–∏–≥–∞—Ü–∏—è
    next_page_button: "button[aria-label='Go to next page']:not([disabled])"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –≤–∞–ª—é—Ç
currency:
  gbp_to_eur: 1.15

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ö—Ä–∞–Ω–µ–Ω–∏—è
storage:
  type: "json"
  output_dir: "./output"
  images_dir: "./images"
  
  database:
    host: "localhost"
    port: 5432
    user: "parser"
    password: "password"
    database: "pricerunner"
    
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging:
  level: "info"
  file: "./logs/parser.log"


================================================
FILE: pricerunner-parser/go.mod
================================================
module pricerunner-parser

go 1.25

require (
	github.com/lib/pq v1.10.9
	github.com/playwright-community/playwright-go v0.5200.0
	gopkg.in/yaml.v3 v3.0.1
)

require (
	github.com/deckarep/golang-set/v2 v2.7.0 // indirect
	github.com/go-jose/go-jose/v3 v3.0.4 // indirect
	github.com/go-stack/stack v1.8.1 // indirect
	github.com/kr/text v0.2.0 // indirect
)



================================================
FILE: pricerunner-parser/main.go
================================================
package main

import (
	"flag"
	"log"
	"pricerunner-parser/internal/config"
	"pricerunner-parser/internal/parser"
	"pricerunner-parser/internal/storage"
)

func main() {
	// –§–ª–∞–≥–∏ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
	configPath := flag.String("config", "config.yaml", "Path to configuration file")
	flag.Parse()

	// –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
	cfg, err := config.Load(*configPath)
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// –°–æ–∑–¥–∞–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ —á–µ—Ä–µ–∑ —Ñ–∞–±—Ä–∏–∫—É
	store, err := storage.NewStorage(cfg)
	if err != nil {
		log.Fatalf("Failed to create storage: %v", err)
	}
	defer store.Close()

	// –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—Å–µ—Ä
	p := parser.New(cfg, store)

	// –ó–∞–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥
	if err := p.Parse(); err != nil {
		log.Fatalf("Parsing failed: %v", err)
	}

	log.Println("Parsing completed successfully!")
}



================================================
FILE: pricerunner-parser/internal/config/config.go
================================================
package config

import (
	"os"

	"gopkg.in/yaml.v3"
)

// Config represents the application configuration
type Config struct {
	Parser   ParserConfig   `yaml:"parser"`
	Currency CurrencyConfig `yaml:"currency"`
	Storage  StorageConfig  `yaml:"storage"`
	Logging  LoggingConfig  `yaml:"logging"`
}

// ParserConfig contains parsing-related settings
type ParserConfig struct {
	BaseURL   string          `yaml:"base_url"`
	Browser   BrowserConfig   `yaml:"browser"`
	Parsing   ParsingConfig   `yaml:"parsing"`
	Selectors SelectorsConfig `yaml:"selectors"`
}

// BrowserConfig contains browser settings
type BrowserConfig struct {
	Headless  bool           `yaml:"headless"`
	Timeout   int            `yaml:"timeout"`
	Viewport  ViewportConfig `yaml:"viewport"`
	UserAgent string         `yaml:"user_agent"`
}

// ViewportConfig contains viewport settings
type ViewportConfig struct {
	Width  int `yaml:"width"`
	Height int `yaml:"height"`
}

// ParsingConfig contains parsing behavior settings
type ParsingConfig struct {
	MaxPages             int `yaml:"max_pages"`
	DelayBetweenRequests int `yaml:"delay_between_requests"`
	ScrollDelay          int `yaml:"scroll_delay"`
	MaxScrolls           int `yaml:"max_scrolls"`
}

// SelectorsConfig contains CSS selectors
type SelectorsConfig struct {
	ProductCards     string `yaml:"product_cards"`
	Price            string `yaml:"price"`
	MainImage        string `yaml:"main_image"`
	AdditionalImages string `yaml:"additional_images"`
	FeatureTables    string `yaml:"feature_tables"`
	NextPageButton   string `yaml:"next_page_button"`
}

// CurrencyConfig contains currency conversion settings
type CurrencyConfig struct {
	GBPToEUR float64 `yaml:"gbp_to_eur"`
}

// StorageConfig contains storage settings
type StorageConfig struct {
	Type      string         `yaml:"type"`
	OutputDir string         `yaml:"output_dir"`
	ImagesDir string         `yaml:"images_dir"`
	Database  DatabaseConfig `yaml:"database"`
}

// DatabaseConfig contains database connection settings
type DatabaseConfig struct {
	Host     string `yaml:"host"`
	Port     int    `yaml:"port"`
	User     string `yaml:"user"`
	Password string `yaml:"password"`
	Database string `yaml:"database"`
}

// LoggingConfig contains logging settings
type LoggingConfig struct {
	Level string `yaml:"level"`
	File  string `yaml:"file"`
}

// Load reads and parses the configuration file
func Load(configPath string) (*Config, error) {
	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, err
	}

	// –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
	if err := os.MkdirAll(config.Storage.OutputDir, 0755); err != nil {
		return nil, err
	}
	if err := os.MkdirAll(config.Storage.ImagesDir, 0755); err != nil {
		return nil, err
	}

	return &config, nil
}



================================================
FILE: pricerunner-parser/internal/downloader/image.go
================================================
package downloader

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// ImageDownloader handles image downloading
type ImageDownloader struct {
	imagesDir string
	client    *http.Client
}

// NewImageDownloader creates a new image downloader
func NewImageDownloader(imagesDir string) *ImageDownloader {
	return &ImageDownloader{
		imagesDir: imagesDir,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// DownloadImage downloads an image and returns the local path
func (d *ImageDownloader) DownloadImage(url, productID string) (string, error) {
	if url == "" || strings.HasPrefix(url, "data:") {
		return "", fmt.Errorf("invalid URL: %s", url)
	}

	// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º URL
	normalizedURL := d.normalizeURL(url)

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
	ext := d.extractExtension(normalizedURL)

	// –°–æ–∑–¥–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
	safeProductID := d.sanitizeFilename(productID)
	filename := fmt.Sprintf("%s.%s", safeProductID, ext)
	localPath := filepath.Join(d.imagesDir, filename)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª
	if _, err := os.Stat(localPath); err == nil {
		return localPath, nil // –§–∞–π–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
	}

	// –°–æ–∑–¥–∞–µ–º HTTP –∑–∞–ø—Ä–æ—Å
	req, err := http.NewRequest("GET", normalizedURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	req.Header.Set("Accept", "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8")
	req.Header.Set("Referer", "https://www.pricerunner.com/")

	// –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
	resp, err := d.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to download image: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("bad status: %d", resp.StatusCode)
	}

	// –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª
	file, err := os.Create(localPath)
	if err != nil {
		return "", fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
	_, err = io.Copy(file, resp.Body)
	if err != nil {
		os.Remove(localPath) // –£–¥–∞–ª—è–µ–º —á–∞—Å—Ç–∏—á–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
		return "", fmt.Errorf("failed to save image: %w", err)
	}

	return localPath, nil
}

// normalizeURL –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
func (d *ImageDownloader) normalizeURL(url string) string {
	if strings.HasPrefix(url, "//") {
		return "https:" + url
	}
	if strings.HasPrefix(url, "/") {
		return "https://www.pricerunner.com" + url
	}
	return url
}

// extractExtension –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏–∑ URL
func (d *ImageDownloader) extractExtension(url string) string {
	re := regexp.MustCompile(`\.([a-zA-Z0-9]+)(?:\?|$)`)
	matches := re.FindStringSubmatch(url)
	if len(matches) > 1 {
		ext := strings.ToLower(matches[1])
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
		validExts := map[string]bool{
			"jpg": true, "jpeg": true, "png": true, "gif": true,
			"webp": true, "avif": true, "svg": true, "bmp": true,
		}
		if validExts[ext] {
			return ext
		}
	}
	return "jpg" // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
}

// sanitizeFilename —Å–æ–∑–¥–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
func (d *ImageDownloader) sanitizeFilename(filename string) string {
	// –ó–∞–º–µ–Ω—è–µ–º –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã –Ω–∞ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è
	re := regexp.MustCompile(`[^\w\-]`)
	return re.ReplaceAllString(filename, "_")
}



================================================
FILE: pricerunner-parser/internal/models/product.go
================================================
package models

import "time"

// Product represents a product with all its details
type Product struct {
	ID          string            `json:"id" db:"id"`
	Title       string            `json:"title" db:"title"`
	URL         string            `json:"url" db:"url"`
	ImageURL    string            `json:"image_url,omitempty" db:"image_url"`
	ImageLocal  string            `json:"image_local,omitempty" db:"image_local"`
	Price       *PriceInfo        `json:"price_info,omitempty" db:"-"`
	Features    map[string]string `json:"features,omitempty" db:"-"`
	Categories  []string          `json:"categories,omitempty" db:"-"`
	ExtraImages []ImageInfo       `json:"additional_images,omitempty" db:"-"`
	CreatedAt   time.Time         `json:"created_at" db:"created_at"`
	UpdatedAt   time.Time         `json:"updated_at" db:"updated_at"`
}

// PriceInfo contains price information
type PriceInfo struct {
	PriceGBP   string  `json:"price_gbp,omitempty"`
	PriceEUR   float64 `json:"price_eur,omitempty"`
	OfferCount string  `json:"offer_count,omitempty"`
}

// ImageInfo contains information about additional images
type ImageInfo struct {
	URL   string `json:"url"`
	Local string `json:"local"`
}

// BasicProduct represents a product with basic information from list page
type BasicProduct struct {
	ID    string `json:"id"`
	Title string `json:"title"`
	URL   string `json:"url"`
}

// ProductExists represents a check for product existence
type ProductExists struct {
	ID     string
	Exists bool
}



================================================
FILE: pricerunner-parser/internal/parser/parser.go
================================================
package parser

import (
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
	"time"

	"pricerunner-parser/internal/config"
	"pricerunner-parser/internal/downloader"
	"pricerunner-parser/internal/models"
	"pricerunner-parser/internal/storage"

	"github.com/playwright-community/playwright-go"
)

// Parser handles the main parsing logic
type Parser struct {
	config     *config.Config
	storage    storage.Storage
	downloader *downloader.ImageDownloader
	playwright *playwright.Playwright
	browser    playwright.Browser
}

// New creates a new parser instance
func New(cfg *config.Config, store storage.Storage) *Parser {
	return &Parser{
		config:     cfg,
		storage:    store,
		downloader: downloader.NewImageDownloader(cfg.Storage.ImagesDir),
	}
}

// Parse starts the parsing process
func (p *Parser) Parse() error {
	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Playwright
	if err := p.initPlaywright(); err != nil {
		return fmt.Errorf("failed to init playwright: %w", err)
	}
	defer p.cleanup()

	var allProducts []models.Product
	pageNumber := 1
	maxPages := p.config.Parser.Parsing.MaxPages

	// –ï—Å–ª–∏ maxPages = 0, —Å—Ç–∞–≤–∏–º —Ä–∞–∑—É–º–Ω—ã–π –ª–∏–º–∏—Ç —á—Ç–æ–±—ã –Ω–µ —É—Ö–æ–¥–∏—Ç—å –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å
	if maxPages == 0 {
		maxPages = 50 // –†–∞–∑—É–º–Ω—ã–π –ª–∏–º–∏—Ç
	}

	for pageNumber <= maxPages {
		log.Printf("\n=== Processing page %d ===", pageNumber)

		// –ü–∞—Ä—Å–∏–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
		basicProducts, hasNextPage, err := p.parseProductList(pageNumber)
		if err != nil {
			log.Printf("Failed to parse page %d: %v", pageNumber, err)
			break
		}

		if len(basicProducts) == 0 {
			log.Printf("No products found on page %d, stopping", pageNumber)
			break
		}

		log.Printf("Found %d products on page %d", len(basicProducts), pageNumber)

		// –§–∏–ª—å—Ç—Ä—É–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–æ–≤–∞—Ä—ã
		newProducts, err := p.filterExistingProducts(basicProducts)
		if err != nil {
			log.Printf("Warning: failed to filter existing products: %v", err)
			newProducts = basicProducts // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–æ –≤—Å–µ–º–∏ —Ç–æ–≤–∞—Ä–∞–º–∏
		}

		log.Printf("New products to process: %d", len(newProducts))

		// –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
		detailedProducts := p.parseProductDetails(newProducts)

		// –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
		if len(detailedProducts) > 0 {
			if err := p.storage.SaveProducts(detailedProducts, pageNumber); err != nil {
				log.Printf("Warning: failed to save page %d: %v", pageNumber, err)
			}
			allProducts = append(allProducts, detailedProducts...)
		}

		log.Printf("=== Page %d completed: %d products processed ===", pageNumber, len(detailedProducts))

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω—É–∂–Ω–æ –ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å
		if !hasNextPage {
			log.Printf("No more pages available, stopping at page %d", pageNumber)
			break
		}

		// –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
		pageNumber++
		log.Printf("Moving to page %d...", pageNumber)
		time.Sleep(time.Duration(p.config.Parser.Parsing.DelayBetweenRequests) * time.Millisecond)
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
	if len(allProducts) > 0 {
		if err := p.storage.SaveFinalData(allProducts); err != nil {
			return fmt.Errorf("failed to save final data: %w", err)
		}

		log.Printf("\nüéâ PARSING COMPLETED SUCCESSFULLY!")
		log.Printf("üìä Total processed: %d products across %d pages", len(allProducts), pageNumber-1)

		// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º
		withPrices := 0
		withImages := 0
		withFeatures := 0

		for _, product := range allProducts {
			if product.Price != nil && product.Price.PriceEUR > 0 {
				withPrices++
			}
			if product.ImageLocal != "" {
				withImages++
			}
			if len(product.Features) > 0 {
				withFeatures++
			}
		}

		log.Printf("üí∞ Products with prices: %d/%d", withPrices, len(allProducts))
		log.Printf("üñºÔ∏è  Products with images: %d/%d", withImages, len(allProducts))
		log.Printf("‚öôÔ∏è  Products with features: %d/%d", withFeatures, len(allProducts))
	}

	return nil
}

// initPlaywright initializes Playwright browser
func (p *Parser) initPlaywright() error {
	pw, err := playwright.Run()
	if err != nil {
		return err
	}
	p.playwright = pw

	browser, err := pw.Chromium.Launch(playwright.BrowserTypeLaunchOptions{
		Headless: &p.config.Parser.Browser.Headless,
		Args: []string{
			"--disable-blink-features=AutomationControlled",
			"--no-sandbox",
			"--disable-setuid-sandbox",
		},
	})
	if err != nil {
		return err
	}
	p.browser = browser

	return nil
}

// cleanup closes browser and playwright
func (p *Parser) cleanup() {
	if p.browser != nil {
		p.browser.Close()
	}
	if p.playwright != nil {
		p.playwright.Stop()
	}
}

// parseProductList parses the product list from a page
func (p *Parser) parseProductList(pageNumber int) ([]models.BasicProduct, bool, error) {
	context, err := p.browser.NewContext(playwright.BrowserNewContextOptions{
		Viewport: &playwright.Size{
			Width:  p.config.Parser.Browser.Viewport.Width,
			Height: p.config.Parser.Browser.Viewport.Height,
		},
		UserAgent: &p.config.Parser.Browser.UserAgent,
	})
	if err != nil {
		return nil, false, err
	}
	defer context.Close()

	page, err := context.NewPage()
	if err != nil {
		return nil, false, err
	}

	// –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –Ω–æ–º–µ—Ä–æ–º
	url := fmt.Sprintf("%s?page=%d", p.config.Parser.BaseURL, pageNumber)
	log.Printf("Loading page: %s", url)

	response, err := page.Goto(url, playwright.PageGotoOptions{
		WaitUntil: playwright.WaitUntilStateDomcontentloaded,
		Timeout:   playwright.Float(float64(p.config.Parser.Browser.Timeout)),
	})
	if err != nil {
		return nil, false, err
	}

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞
	if response.Status() == 404 {
		log.Printf("  Page %d returned 404, no more pages", pageNumber)
		return nil, false, nil
	}

	// –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤
	_, err = page.WaitForSelector(p.config.Parser.Selectors.ProductCards, playwright.PageWaitForSelectorOptions{
		Timeout: playwright.Float(10000),
	})
	if err != nil {
		log.Printf("  No products found on page %d", pageNumber)
		return nil, false, nil
	}

	// –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤
	p.scrollPage(page)

	// –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–≤–∞—Ä—ã
	products := p.extractProductCards(page)

	if len(products) == 0 {
		log.Printf("  No products extracted from page %d", pageNumber)
		return nil, false, nil
	}

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –µ—Å—Ç—å –ª–∏ —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ç–æ–≤–∞—Ä–æ–≤
	hasNextPage := p.hasNextPage(len(products), pageNumber)

	return products, hasNextPage, nil
}

// scrollPage scrolls the page to load all products
func (p *Parser) scrollPage(page playwright.Page) {
	scrollDelay := time.Duration(p.config.Parser.Parsing.ScrollDelay) * time.Millisecond
	maxScrolls := p.config.Parser.Parsing.MaxScrolls

	log.Println("Scrolling page to load all products...")

	var lastHeight float64
	stableCount := 0

	for i := 0; i < maxScrolls; i++ {
		// –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –≤–Ω–∏–∑
		page.Evaluate("window.scrollBy(0, 500)")
		time.Sleep(scrollDelay)

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –ª–∏ –≤—ã—Å–æ—Ç–∞
		heightResult, err := page.Evaluate("document.body.scrollHeight")
		if err != nil {
			break
		}

		var currentHeight float64
		switch h := heightResult.(type) {
		case int:
			currentHeight = float64(h)
		case int64:
			currentHeight = float64(h)
		case float64:
			currentHeight = h
		case float32:
			currentHeight = float64(h)
		default:
			currentHeight = 0
		}

		if currentHeight == lastHeight {
			stableCount++
			if stableCount >= 3 {
				break
			}
		} else {
			stableCount = 0
		}

		lastHeight = currentHeight
	}

	// –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –Ω–∞–≤–µ—Ä—Ö
	page.Evaluate("window.scrollTo(0, 0)")
	time.Sleep(time.Second)
}

// extractProductCards extracts product information from page
func (p *Parser) extractProductCards(page playwright.Page) []models.BasicProduct {
	cards, err := page.QuerySelectorAll(p.config.Parser.Selectors.ProductCards)
	if err != nil {
		log.Printf("Error querying product cards: %v", err)
		return nil
	}

	var products []models.BasicProduct

	for _, card := range cards {
		title, err := card.GetAttribute("title")
		if err != nil || title == "" {
			continue
		}

		href, err := card.GetAttribute("href")
		if err != nil || href == "" {
			continue
		}

		// –ò–∑–≤–ª–µ–∫–∞–µ–º ID –∏–∑ URL
		re := regexp.MustCompile(`/pl/(\d+-\d+)/`)
		matches := re.FindStringSubmatch(href)
		if len(matches) < 2 {
			continue
		}

		productID := matches[1]

		// –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π URL
		fullURL := href
		if !strings.HasPrefix(href, "http") {
			fullURL = "https://www.pricerunner.com" + href
		}

		products = append(products, models.BasicProduct{
			ID:    productID,
			Title: title,
			URL:   fullURL,
		})
	}

	return products
}

// hasNextPage checks if there's a next page based on product count
func (p *Parser) hasNextPage(productsCount int, pageNumber int) bool {
	log.Printf("  Checking if page %d has next page...", pageNumber)

	// –ï—Å–ª–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –º–µ–Ω—å—à–µ —Ç–æ–≤–∞—Ä–æ–≤ —á–µ–º –æ–±—ã—á–Ω–æ, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
	expectedProductsPerPage := 48

	if productsCount < expectedProductsPerPage {
		log.Printf("    Found only %d products (expected ~%d), likely last page", productsCount, expectedProductsPerPage)
		return false
	}

	// –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —á–∏—Å–ª–∞ —Å—Ç—Ä–∞–Ω–∏—Ü –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
	if p.config.Parser.Parsing.MaxPages > 0 && pageNumber >= p.config.Parser.Parsing.MaxPages {
		log.Printf("    Reached max pages limit (%d)", p.config.Parser.Parsing.MaxPages)
		return false
	}

	log.Printf("    ‚úì Page %d has %d products, assuming next page exists", pageNumber, productsCount)
	return true
}

// filterExistingProducts filters out products that already exist
func (p *Parser) filterExistingProducts(products []models.BasicProduct) ([]models.BasicProduct, error) {
	existingIDs, err := p.storage.GetExistingProducts()
	if err != nil {
		return products, err // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ —Ç–æ–≤–∞—Ä—ã –µ—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
	}

	existingSet := make(map[string]bool)
	for _, id := range existingIDs {
		existingSet[id] = true
	}

	var newProducts []models.BasicProduct
	for _, product := range products {
		if !existingSet[product.ID] {
			newProducts = append(newProducts, product)
		}
	}

	return newProducts, nil
}

// parseProductDetails gets detailed information for each product
func (p *Parser) parseProductDetails(products []models.BasicProduct) []models.Product {
	var detailedProducts []models.Product

	for i, basicProduct := range products {
		log.Printf("[%d/%d] Processing: %s (ID: %s)", i+1, len(products),
			truncateString(basicProduct.Title, 50), basicProduct.ID)

		details, err := p.parseProductDetail(basicProduct)
		if err != nil {
			log.Printf("  ‚úó Failed to parse details: %v", err)
			continue
		}

		detailedProducts = append(detailedProducts, *details)

		// –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
		var stats []string

		if details.Price != nil && details.Price.PriceEUR > 0 {
			stats = append(stats, fmt.Sprintf("Price: ‚Ç¨%.2f", details.Price.PriceEUR))
		}

		if details.ImageLocal != "" {
			stats = append(stats, "Image: ‚úì")
		}

		if len(details.Features) > 0 {
			stats = append(stats, fmt.Sprintf("Features: %d", len(details.Features)))
		}

		if len(details.ExtraImages) > 0 {
			stats = append(stats, fmt.Sprintf("ExtraImg: %d", len(details.ExtraImages)))
		}

		// –í—ã–≤–æ–¥–∏–º –≤—Å–µ –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
		if len(stats) > 0 {
			log.Printf("  ‚úì %s", strings.Join(stats, ", "))
		}

		// –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
		time.Sleep(time.Duration(p.config.Parser.Parsing.DelayBetweenRequests) * time.Millisecond)
	}

	return detailedProducts
}

// parseProductDetail parses detailed information for a single product
func (p *Parser) parseProductDetail(basic models.BasicProduct) (*models.Product, error) {
	context, err := p.browser.NewContext(playwright.BrowserNewContextOptions{
		Viewport: &playwright.Size{
			Width:  p.config.Parser.Browser.Viewport.Width,
			Height: p.config.Parser.Browser.Viewport.Height,
		},
		UserAgent: &p.config.Parser.Browser.UserAgent,
	})
	if err != nil {
		return nil, err
	}
	defer context.Close()

	page, err := context.NewPage()
	if err != nil {
		return nil, err
	}

	// –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ç–æ–≤–∞—Ä–∞
	if _, err := page.Goto(basic.URL, playwright.PageGotoOptions{
		WaitUntil: playwright.WaitUntilStateDomcontentloaded,
		Timeout:   playwright.Float(float64(p.config.Parser.Browser.Timeout)),
	}); err != nil {
		return nil, err
	}

	// –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–∞—É–∑–∞ –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
	time.Sleep(500 * time.Millisecond)

	// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
	p.scrollToFeatures(page)

	// –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –ø—Ä–æ–¥—É–∫—Ç–∞
	product := &models.Product{
		ID:        basic.ID,
		Title:     basic.Title,
		URL:       basic.URL,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// –ü–∞—Ä—Å–∏–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
	product.Price = p.parsePrice(page)
	p.parseMainImage(page, product)
	product.ExtraImages = p.parseAdditionalImages(page, basic.ID)
	product.Features = p.parseFeatures(page)

	return product, nil
}

// scrollToFeatures —É–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
func (p *Parser) scrollToFeatures(page playwright.Page) {
	log.Printf("  Loading all page content...")

	// –°—Ç—Ä–∞—Ç–µ–≥–∏—è: –±—ã—Å—Ç—Ä–æ –ø—Ä–æ–∫—Ä—É—Ç–∏—Ç—å –≤—Å—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞

	// 1. –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
	page.Evaluate("window.scrollTo(0, document.body.scrollHeight)")
	time.Sleep(1 * time.Second)

	// 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ç–∞–±–ª–∏—Ü—ã
	tablesCount := p.checkTablesCountQuick(page)
	log.Printf("    After full scroll: %d tables found", tablesCount)

	// 3. –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü –º–∞–ª–æ, –¥–µ–ª–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
	if tablesCount < 2 {
		log.Printf("    Need more content, doing additional scrolling...")

		// –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∫ —Ä–∞–∑–Ω—ã–º —á–∞—Å—Ç—è–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã
		positions := []string{
			"document.body.scrollHeight * 0.75", // 75%
			"document.body.scrollHeight * 0.5",  // 50%
			"document.body.scrollHeight * 0.25", // 25%
		}

		for _, pos := range positions {
			page.Evaluate(fmt.Sprintf("window.scrollTo(0, %s)", pos))
			time.Sleep(500 * time.Millisecond)
		}

		// –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –∫ –∫–æ–Ω—Ü—É
		page.Evaluate("window.scrollTo(0, document.body.scrollHeight)")
		time.Sleep(1 * time.Second)
	}

	// 4. –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º—Å—è –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
	page.Evaluate("window.scrollTo(0, document.body.scrollHeight / 2)")
	time.Sleep(500 * time.Millisecond)

	finalCount := p.checkTablesCountQuick(page)
	log.Printf("    Final: %d tables loaded", finalCount)
}

// checkTablesCountQuick –±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–∞–±–ª–∏—Ü
func (p *Parser) checkTablesCountQuick(page playwright.Page) int {
	// –ü—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–µ–ª–µ–∫—Ç–æ—Ä
	tables, err := page.QuerySelectorAll(p.config.Parser.Selectors.FeatureTables)
	if err == nil && len(tables) > 0 {
		return len(tables)
	}

	// –ü—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
	altSelectors := []string{
		"table.pr-1regpt0-Table-table",
		"div[class*='Table'] table",
		"table",
	}

	maxCount := 0
	for _, selector := range altSelectors {
		tables, err := page.QuerySelectorAll(selector)
		if err == nil && len(tables) > maxCount {
			maxCount = len(tables)
		}
	}

	return maxCount
}

// parsePrice parses price using the improved selector for second span
func (p *Parser) parsePrice(page playwright.Page) *models.PriceInfo {
	log.Printf("    Looking for price (second span)...")

	// –°–ø–æ—Å–æ–± 1: –ò—â–µ–º –≤—Å–µ span'—ã —Å –Ω—É–∂–Ω—ã–º –∫–ª–∞—Å—Å–æ–º –∏ –±–µ—Ä–µ–º –≤—Ç–æ—Ä–æ–π
	priceElements, err := page.QuerySelectorAll("span.pr-1fcg5be")
	if err != nil || len(priceElements) < 2 {
		log.Printf("    Not enough price elements found (need 2, got %d)", len(priceElements))
		return p.parsePriceFallback(page)
	}

	// –ë–µ—Ä–µ–º –≤—Ç–æ—Ä–æ–π —ç–ª–µ–º–µ–Ω—Ç (–∏–Ω–¥–µ–∫—Å 1)
	secondPriceElement := priceElements[1]

	priceText, err := secondPriceElement.InnerText()
	if err != nil || priceText == "" {
		log.Printf("    Failed to get text from second price element")
		return p.parsePriceFallback(page)
	}

	priceText = strings.TrimSpace(priceText)
	log.Printf("    Found price (second span): %s", priceText)

	// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ EUR
	priceEUR := p.convertGBPToEUR(priceText)

	return &models.PriceInfo{
		PriceGBP: priceText,
		PriceEUR: priceEUR,
	}
}

// parsePriceFallback - –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –ø–æ–∏—Å–∫–∞ —Ü–µ–Ω—ã
func (p *Parser) parsePriceFallback(page playwright.Page) *models.PriceInfo {
	log.Printf("    Trying fallback price selectors...")

	// –°–ø–æ—Å–æ–± 2: –ò—â–µ–º –ø–æ —Ç–µ–∫—Å—Ç—É "Lowest Price Now"
	nowPriceSelector := `//p[contains(text(), "Lowest Price Now")]/following-sibling::span[@class="pr-1fcg5be"]`
	if priceElement, err := page.QuerySelector(nowPriceSelector); err == nil && priceElement != nil {
		if priceText, err := priceElement.InnerText(); err == nil && priceText != "" {
			log.Printf("    Found price via 'Lowest Price Now': %s", strings.TrimSpace(priceText))
			return &models.PriceInfo{
				PriceGBP: strings.TrimSpace(priceText),
				PriceEUR: p.convertGBPToEUR(priceText),
			}
		}
	}

	// –°–ø–æ—Å–æ–± 3: –ò—â–µ–º –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ DOM - –≤—Ç–æ—Ä–æ–π div —Å –∫–ª–∞—Å—Å–æ–º pr-i5pc8s
	structureSelector := `div.pr-1ymxntz div.pr-i5pc8s:nth-child(2) span.pr-1fcg5be`
	if priceElement, err := page.QuerySelector(structureSelector); err == nil && priceElement != nil {
		if priceText, err := priceElement.InnerText(); err == nil && priceText != "" {
			log.Printf("    Found price via structure selector: %s", strings.TrimSpace(priceText))
			return &models.PriceInfo{
				PriceGBP: strings.TrimSpace(priceText),
				PriceEUR: p.convertGBPToEUR(priceText),
			}
		}
	}

	log.Printf("    ‚ö† No price found with any method")
	return nil
}

// convertGBPToEUR converts GBP price to EUR
func (p *Parser) convertGBPToEUR(priceStr string) float64 {
	// –£–¥–∞–ª—è–µ–º —Å–∏–º–≤–æ–ª—ã –≤–∞–ª—é—Ç—ã –∏ –ø—Ä–æ–±–µ–ª—ã
	re := regexp.MustCompile(`[¬£‚Ç¨\s,]`)
	cleanPrice := re.ReplaceAllString(priceStr, "")

	price, err := strconv.ParseFloat(cleanPrice, 64)
	if err != nil {
		return 0
	}

	return price * p.config.Currency.GBPToEUR
}

// parseMainImage parses the main product image
func (p *Parser) parseMainImage(page playwright.Page, product *models.Product) {
	log.Printf("  Looking for images...")

	selectors := []string{
		p.config.Parser.Selectors.MainImage,
		"picture.pr-lpjxdi source[type='image/jpeg']",
		"img[itemprop='image']",
		"div.pr-15dcama img",
	}

	var imageURL string

	for _, selector := range selectors {
		if strings.Contains(selector, "source") {
			source, err := page.QuerySelector(selector)
			if err == nil && source != nil {
				srcset, _ := source.GetAttribute("srcset")
				if srcset != "" {
					urls := strings.Split(srcset, ",")
					if len(urls) > 0 {
						imageURL = strings.TrimSpace(strings.Fields(urls[len(urls)-1])[0])
						break
					}
				}
			}
		} else {
			img, err := page.QuerySelector(selector)
			if err == nil && img != nil {
				srcset, _ := img.GetAttribute("srcset")
				if srcset != "" {
					urls := strings.Split(srcset, ",")
					if len(urls) > 0 {
						imageURL = strings.TrimSpace(strings.Fields(urls[len(urls)-1])[0])
						break
					}
				} else {
					src, _ := img.GetAttribute("src")
					if src != "" && !strings.HasPrefix(src, "data:") {
						imageURL = src
						break
					}
				}
			}
		}
	}

	product.ImageURL = imageURL

	if imageURL != "" {
		localPath, err := p.downloader.DownloadImage(imageURL, product.ID)
		if err != nil {
			log.Printf("    ‚úó Failed to download main image: %v", err)
		} else {
			product.ImageLocal = localPath
		}
	} else {
		log.Printf("    ‚ö† Main image not found")
	}
}

// parseAdditionalImages parses additional product images
func (p *Parser) parseAdditionalImages(page playwright.Page, productID string) []models.ImageInfo {
	log.Printf("  Looking for additional images...")

	thumbnails, err := page.QuerySelectorAll(p.config.Parser.Selectors.AdditionalImages)
	if err != nil {
		return nil
	}

	var additionalImages []models.ImageInfo
	maxImages := 3 // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏

	for i, thumb := range thumbnails {
		if i >= maxImages {
			break
		}

		src, err := thumb.GetAttribute("src")
		if err != nil || src == "" || strings.HasPrefix(src, "data:") {
			continue
		}

		// –ó–∞–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –Ω–∞ –±–æ–ª—å—à–∏–π
		re := regexp.MustCompile(`/\d+x\d+/`)
		largeURL := re.ReplaceAllString(src, "/504x504/")

		localPath, err := p.downloader.DownloadImage(largeURL, fmt.Sprintf("%s_extra_%d", productID, i+1))
		if err != nil {
			log.Printf("    ‚úó Failed to download additional image %d: %v", i+1, err)
			continue
		}

		additionalImages = append(additionalImages, models.ImageInfo{
			URL:   largeURL,
			Local: localPath,
		})
	}

	return additionalImages
}

// parseFeatures –ø–∞—Ä—Å–∏–Ω–≥ —Ç–∞–±–ª–∏—Ü—ã —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏ –≤–Ω—É—Ç—Ä–∏
func (p *Parser) parseFeatures(page playwright.Page) map[string]string {
	log.Printf("  Extracting features...")

	features := make(map[string]string)

	// –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è —Ç–∞–±–ª–∏—Ü
	tableSelectors := []string{
		p.config.Parser.Selectors.FeatureTables, // –û—Å–Ω–æ–≤–Ω–æ–π
		"table.pr-1regpt0-Table-table",          // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π
		"div[class*='Table'] table",             // –ü–æ —á–∞—Å—Ç–∏ –∫–ª–∞—Å—Å–∞
		"table",                                 // –õ—é–±—ã–µ —Ç–∞–±–ª–∏—Ü—ã
	}

	var tables []playwright.ElementHandle

	for _, selector := range tableSelectors {
		foundTables, err := page.QuerySelectorAll(selector)
		if err == nil && len(foundTables) > 0 {
			tables = foundTables
			log.Printf("    Found %d tables with selector: %s", len(foundTables), selector)
			break
		}
	}

	if len(tables) == 0 {
		log.Printf("    ‚ö† No feature tables found with any selector")
		return features
	}

	// –ü–∞—Ä—Å–∏–º –∫–∞–∂–¥—É—é —Ç–∞–±–ª–∏—Ü—É
	for tableIdx, table := range tables {
		log.Printf("    Processing table %d/%d", tableIdx+1, len(tables))

		// –ü–∞—Ä—Å–∏–º —Ç–∞–±–ª–∏—Ü—É —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
		tableFeatures := p.parseTableWithMultipleHeaders(table)

		// –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å –æ–±—â–∏–º —Å–ø–∏—Å–∫–æ–º
		for key, value := range tableFeatures {
			features[key] = value
		}
	}

	if len(features) > 0 {
		log.Printf("    ‚úì Total features found: %d", len(features))
	} else {
		log.Printf("    ‚ö† No valid features extracted")
	}

	return features
}

// –ò—Å–ø—Ä–∞–≤–ª—è–µ–º parseTableWithMultipleHeaders - —É–±–∏—Ä–∞–µ–º –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
func (p *Parser) parseTableWithMultipleHeaders(table playwright.ElementHandle) map[string]string {
	features := make(map[string]string)

	// –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã (–∏ thead, –∏ tbody)
	allRows, err := table.QuerySelectorAll("tr")
	if err != nil {
		return features
	}

	currentCategory := "General"

	for _, row := range allRows { // –£–±—Ä–∞–ª–∏ i, _
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
		if p.isHeaderRow(row) {
			// –≠—Ç–æ —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞ - –∏–∑–≤–ª–µ–∫–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
			category := p.extractCategoryFromHeaderRow(row)
			if category != "" {
				currentCategory = category
				log.Printf("      Found category header: '%s'", currentCategory)
			}
			continue
		}

		// –≠—Ç–æ —Å—Ç—Ä–æ–∫–∞ –¥–∞–Ω–Ω—ã—Ö - –ø–∞—Ä—Å–∏–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
		featureName, featureValue := p.extractFeatureFromRow(row)
		if featureName != "" && featureValue != "" {
			// –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∫ –Ω–∞–∑–≤–∞–Ω–∏—é –µ—Å–ª–∏ –æ–Ω–∞ –∑–Ω–∞—á–∏–º–∞—è
			key := featureName
			if currentCategory != "General" && currentCategory != "" {
				key = fmt.Sprintf("%s: %s", currentCategory, featureName)
			}

			features[key] = featureValue
		}
	}

	log.Printf("      Extracted %d features from table", len(features))
	return features
}

// isHeaderRow –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
func (p *Parser) isHeaderRow(row playwright.ElementHandle) bool {
	// –°–ø–æ—Å–æ–± 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π —ç–ª–µ–º–µ–Ω—Ç (thead)
	script := `
		let row = arguments[0];
		let parent = row.parentElement;
		return parent && parent.tagName === 'THEAD';
	`
	if result, err := row.Evaluate(script); err == nil {
		if isInThead, ok := result.(bool); ok && isInThead {
			return true
		}
	}

	// –°–ø–æ—Å–æ–± 2: –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ th –≤–º–µ—Å—Ç–æ td
	ths, err := row.QuerySelectorAll("th")
	if err == nil && len(ths) > 0 {
		return true
	}

	// –°–ø–æ—Å–æ–± 3: –ü—Ä–æ–≤–µ—Ä—è–µ–º CSS –∫–ª–∞—Å—Å –∏–ª–∏ data-–∞—Ç—Ä–∏–±—É—Ç—ã
	class, _ := row.GetAttribute("class")
	dataKind, _ := row.GetAttribute("data-kind")

	if strings.Contains(class, "heading") || strings.Contains(class, "header") ||
		dataKind == "heading" || dataKind == "header" {
		return true
	}

	// –°–ø–æ—Å–æ–± 4: –ü—Ä–æ–≤–µ—Ä—è–µ–º —è—á–µ–π–∫–∏ —Å data-kind="heading"
	cells, err := row.QuerySelectorAll("td, th")
	if err == nil {
		for _, cell := range cells {
			if cellDataKind, _ := cell.GetAttribute("data-kind"); cellDataKind == "heading" {
				return true
			}
		}
	}

	return false
}

// extractCategoryFromHeaderRow –∏–∑–≤–ª–µ–∫–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ —Å—Ç—Ä–æ–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞
func (p *Parser) extractCategoryFromHeaderRow(row playwright.ElementHandle) string {
	// –ò—â–µ–º div.pr-f8aw3g —Å —Ç–µ–∫—Å—Ç–æ–º
	if categoryDiv, err := row.QuerySelector("div.pr-f8aw3g"); err == nil && categoryDiv != nil {
		if categoryText, err := categoryDiv.InnerText(); err == nil && categoryText != "" {
			cleaned := strings.TrimSpace(categoryText)
			if p.isValidCategory(cleaned) {
				return cleaned
			}
		}
	}

	// –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ - –∏—â–µ–º –≤ th
	if th, err := row.QuerySelector("th"); err == nil && th != nil {
		if categoryText, err := th.InnerText(); err == nil && categoryText != "" {
			cleaned := strings.TrimSpace(categoryText)
			if p.isValidCategory(cleaned) {
				return cleaned
			}
		}
	}

	// –ò—â–µ–º –≤ –ª—é–±–æ–π —è—á–µ–π–∫–µ
	cells, err := row.QuerySelectorAll("td, th")
	if err == nil && len(cells) > 0 {
		if categoryText, err := cells[0].InnerText(); err == nil && categoryText != "" {
			cleaned := strings.TrimSpace(categoryText)
			if p.isValidCategory(cleaned) {
				return cleaned
			}
		}
	}

	return ""
}

// extractFeatureFromRow –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫—É –∏–∑ —Å—Ç—Ä–æ–∫–∏ –¥–∞–Ω–Ω—ã—Ö
func (p *Parser) extractFeatureFromRow(row playwright.ElementHandle) (string, string) {
	// –ü–æ–ª—É—á–∞–µ–º —è—á–µ–π–∫–∏ td (–Ω–µ th)
	cells, err := row.QuerySelectorAll("td")
	if err != nil || len(cells) < 2 {
		return "", ""
	}

	// –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ –∑–Ω–∞—á–µ–Ω–∏–µ
	featureName, _ := cells[0].InnerText()
	featureValue, _ := cells[1].InnerText()

	featureName = strings.TrimSpace(featureName)
	featureValue = strings.TrimSpace(featureValue)

	// –í–∞–ª–∏–¥–∞—Ü–∏—è
	if !p.isValidFeaturePair(featureName, featureValue) {
		return "", ""
	}

	return featureName, featureValue
}

// isValidCategory –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤–∞–ª–∏–¥–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
func (p *Parser) isValidCategory(category string) bool {
	if len(category) < 2 || len(category) > 50 {
		return false
	}

	// –ò—Å–∫–ª—é—á–∞–µ–º –ø—É—Å—Ç—ã–µ –∏–ª–∏ —Å–ª—É–∂–µ–±–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
	excludes := []string{"", " ", "-", "‚Äì", "‚Äî", "N/A", "n/a", "TBD", "tbd"}
	for _, exclude := range excludes {
		if category == exclude {
			return false
		}
	}

	return true
}

// isValidFeaturePair –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –ø–∞—Ä—ã –Ω–∞–∑–≤–∞–Ω–∏–µ-–∑–Ω–∞—á–µ–Ω–∏–µ
func (p *Parser) isValidFeaturePair(name, value string) bool {
	if name == "" || value == "" {
		return false
	}

	if name == value {
		return false
	}

	if len(name) < 2 || len(value) < 1 {
		return false
	}

	// –ò—Å–∫–ª—é—á–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
	if strings.Contains(strings.ToLower(name), "compare") {
		return false
	}

	return true
}

// –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é truncateString –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞
func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}



================================================
FILE: pricerunner-parser/internal/storage/database.go
================================================
package storage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"

	"pricerunner-parser/internal/config"
	"pricerunner-parser/internal/models"

	_ "github.com/lib/pq" // PostgreSQL driver
)

// DatabaseStorage implements Storage interface for PostgreSQL
type DatabaseStorage struct {
	db *sql.DB
}

// NewDatabaseStorage creates a new database storage instance
func NewDatabaseStorage(cfg config.DatabaseConfig) (*DatabaseStorage, error) {
	dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Database)

	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	storage := &DatabaseStorage{db: db}

	// –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
	if err := storage.createTables(); err != nil {
		return nil, fmt.Errorf("failed to create tables: %w", err)
	}

	return storage, nil
}

// createTables creates necessary database tables
func (d *DatabaseStorage) createTables() error {
	queries := []string{
		`CREATE TABLE IF NOT EXISTS products (
			id VARCHAR(50) PRIMARY KEY,
			title TEXT NOT NULL,
			url TEXT NOT NULL,
			image_url TEXT,
			image_local TEXT,
			price_gbp VARCHAR(20),
			price_eur DECIMAL(10,2),
			offer_count VARCHAR(10),
			features JSONB,
			categories TEXT[],
			additional_images JSONB,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)`,
		`CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)`,
		`CREATE INDEX IF NOT EXISTS idx_products_price_eur ON products(price_eur)`,
		`CREATE INDEX IF NOT EXISTS idx_products_title ON products USING gin(to_tsvector('english', title))`,
	}

	for _, query := range queries {
		if _, err := d.db.Exec(query); err != nil {
			return fmt.Errorf("failed to execute query: %w", err)
		}
	}

	return nil
}

// SaveProducts saves products to database (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –≤ –æ—Å–Ω–æ–≤–Ω—É—é —Ç–∞–±–ª–∏—Ü—É)
func (d *DatabaseStorage) SaveProducts(products []models.Product, pageNumber int) error {
	if len(products) == 0 {
		return nil
	}

	// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏
	tx, err := d.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	query := `
		INSERT INTO products (
			id, title, url, image_url, image_local, 
			price_gbp, price_eur, offer_count, 
			features, categories, additional_images, 
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
		ON CONFLICT (id) DO UPDATE SET
			title = EXCLUDED.title,
			url = EXCLUDED.url,
			image_url = EXCLUDED.image_url,
			image_local = EXCLUDED.image_local,
			price_gbp = EXCLUDED.price_gbp,
			price_eur = EXCLUDED.price_eur,
			offer_count = EXCLUDED.offer_count,
			features = EXCLUDED.features,
			categories = EXCLUDED.categories,
			additional_images = EXCLUDED.additional_images,
			updated_at = EXCLUDED.updated_at
	`

	stmt, err := tx.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, product := range products {
		// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å–ª–æ–∂–Ω—ã–µ –ø–æ–ª—è –≤ JSON
		featuresJSON, _ := json.Marshal(product.Features)
		categoriesArray := fmt.Sprintf("{%s}", strings.Join(product.Categories, ","))
		additionalImagesJSON, _ := json.Marshal(product.ExtraImages)

		var priceGBP string
		var priceEUR sql.NullFloat64
		var offerCount string

		if product.Price != nil {
			priceGBP = product.Price.PriceGBP
			if product.Price.PriceEUR > 0 {
				priceEUR = sql.NullFloat64{Float64: product.Price.PriceEUR, Valid: true}
			}
			offerCount = product.Price.OfferCount
		}

		_, err := stmt.Exec(
			product.ID,
			product.Title,
			product.URL,
			product.ImageURL,
			product.ImageLocal,
			priceGBP,
			priceEUR,
			offerCount,
			featuresJSON,
			categoriesArray,
			additionalImagesJSON,
			product.CreatedAt,
			product.UpdatedAt,
		)
		if err != nil {
			return fmt.Errorf("failed to insert product %s: %w", product.ID, err)
		}
	}

	return tx.Commit()
}

// SaveFinalData –¥–ª—è –ë–î —ç—Ç–æ —Ç–æ –∂–µ —Å–∞–º–æ–µ —á—Ç–æ –∏ SaveProducts
func (d *DatabaseStorage) SaveFinalData(products []models.Product) error {
	return d.SaveProducts(products, 0)
}

// ProductExists checks if a product exists in database
func (d *DatabaseStorage) ProductExists(productID string) (bool, error) {
	var exists bool
	query := "SELECT EXISTS(SELECT 1 FROM products WHERE id = $1)"
	err := d.db.QueryRow(query, productID).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check product existence: %w", err)
	}
	return exists, nil
}

// GetExistingProducts returns all existing product IDs
func (d *DatabaseStorage) GetExistingProducts() ([]string, error) {
	query := "SELECT id FROM products ORDER BY created_at DESC"
	rows, err := d.db.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to query existing products: %w", err)
	}
	defer rows.Close()

	var productIDs []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			continue
		}
		productIDs = append(productIDs, id)
	}

	return productIDs, nil
}

// GetProductsByPriceRange returns products within price range
func (d *DatabaseStorage) GetProductsByPriceRange(minPrice, maxPrice float64) ([]models.Product, error) {
	query := `
		SELECT id, title, url, image_url, image_local, 
			   price_gbp, price_eur, offer_count, 
			   features, categories, additional_images,
			   created_at, updated_at 
		FROM products 
		WHERE price_eur BETWEEN $1 AND $2 
		ORDER BY price_eur ASC
	`

	rows, err := d.db.Query(query, minPrice, maxPrice)
	if err != nil {
		return nil, fmt.Errorf("failed to query products by price: %w", err)
	}
	defer rows.Close()

	return d.scanProducts(rows)
}

// SearchProducts searches products by title
func (d *DatabaseStorage) SearchProducts(searchTerm string) ([]models.Product, error) {
	query := `
		SELECT id, title, url, image_url, image_local, 
			   price_gbp, price_eur, offer_count, 
			   features, categories, additional_images,
			   created_at, updated_at 
		FROM products 
		WHERE to_tsvector('english', title) @@ plainto_tsquery('english', $1)
		ORDER BY created_at DESC
	`

	rows, err := d.db.Query(query, searchTerm)
	if err != nil {
		return nil, fmt.Errorf("failed to search products: %w", err)
	}
	defer rows.Close()

	return d.scanProducts(rows)
}

// GetProductStats returns statistics about products
func (d *DatabaseStorage) GetProductStats() (map[string]interface{}, error) {
	stats := make(map[string]interface{})

	// –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
	var totalCount int
	if err := d.db.QueryRow("SELECT COUNT(*) FROM products").Scan(&totalCount); err == nil {
		stats["total_products"] = totalCount
	}

	// –° —Ü–µ–Ω–∞–º–∏
	var withPrices int
	if err := d.db.QueryRow("SELECT COUNT(*) FROM products WHERE price_eur IS NOT NULL").Scan(&withPrices); err == nil {
		stats["products_with_prices"] = withPrices
	}

	// –° –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
	var withImages int
	if err := d.db.QueryRow("SELECT COUNT(*) FROM products WHERE image_local IS NOT NULL AND image_local != ''").Scan(&withImages); err == nil {
		stats["products_with_images"] = withImages
	}

	// –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞
	var avgPrice sql.NullFloat64
	if err := d.db.QueryRow("SELECT AVG(price_eur) FROM products WHERE price_eur IS NOT NULL").Scan(&avgPrice); err == nil && avgPrice.Valid {
		stats["average_price"] = avgPrice.Float64
	}

	// –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ü–µ–Ω—ã
	var minPrice, maxPrice sql.NullFloat64
	if err := d.db.QueryRow("SELECT MIN(price_eur), MAX(price_eur) FROM products WHERE price_eur IS NOT NULL").Scan(&minPrice, &maxPrice); err == nil {
		if minPrice.Valid {
			stats["min_price"] = minPrice.Float64
		}
		if maxPrice.Valid {
			stats["max_price"] = maxPrice.Float64
		}
	}

	return stats, nil
}

// scanProducts helper function to scan rows into Product structs
func (d *DatabaseStorage) scanProducts(rows *sql.Rows) ([]models.Product, error) {
	var products []models.Product

	for rows.Next() {
		var product models.Product
		var featuresJSON, additionalImagesJSON []byte
		var categories string
		var priceGBP string
		var priceEUR sql.NullFloat64
		var offerCount string

		err := rows.Scan(
			&product.ID,
			&product.Title,
			&product.URL,
			&product.ImageURL,
			&product.ImageLocal,
			&priceGBP,
			&priceEUR,
			&offerCount,
			&featuresJSON,
			&categories,
			&additionalImagesJSON,
			&product.CreatedAt,
			&product.UpdatedAt,
		)
		if err != nil {
			continue
		}

		// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ª–æ–∂–Ω—ã–µ –ø–æ–ª—è
		if len(featuresJSON) > 0 {
			json.Unmarshal(featuresJSON, &product.Features)
		}

		if len(additionalImagesJSON) > 0 {
			json.Unmarshal(additionalImagesJSON, &product.ExtraImages)
		}

		// –ü–∞—Ä—Å–∏–º –º–∞—Å—Å–∏–≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–π
		if categories != "" {
			categories = strings.Trim(categories, "{}")
			if categories != "" {
				product.Categories = strings.Split(categories, ",")
			}
		}

		// –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–µ–Ω—É
		if priceGBP != "" || priceEUR.Valid {
			product.Price = &models.PriceInfo{
				PriceGBP:   priceGBP,
				OfferCount: offerCount,
			}
			if priceEUR.Valid {
				product.Price.PriceEUR = priceEUR.Float64
			}
		}

		products = append(products, product)
	}

	return products, nil
}

// Close closes the database connection
func (d *DatabaseStorage) Close() error {
	if d.db != nil {
		return d.db.Close()
	}
	return nil
}



================================================
FILE: pricerunner-parser/internal/storage/factory.go
================================================
package storage

import (
	"fmt"
	"pricerunner-parser/internal/config"
)

// NewStorage creates a storage instance based on configuration
func NewStorage(cfg *config.Config) (Storage, error) {
	switch cfg.Storage.Type {
	case "json":
		return NewJSONStorage(cfg.Storage.OutputDir), nil
	case "database":
		return NewDatabaseStorage(cfg.Storage.Database)
	default:
		return nil, fmt.Errorf("unsupported storage type: %s", cfg.Storage.Type)
	}
}



================================================
FILE: pricerunner-parser/internal/storage/json.go
================================================
package storage

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"pricerunner-parser/internal/models"
)

// JSONStorage implements Storage interface for JSON files
type JSONStorage struct {
	outputDir string
}

// NewJSONStorage creates a new JSON storage instance
func NewJSONStorage(outputDir string) *JSONStorage {
	return &JSONStorage{
		outputDir: outputDir,
	}
}

// SaveProducts saves products to a page-specific JSON file
func (j *JSONStorage) SaveProducts(products []models.Product, pageNumber int) error {
	if len(products) == 0 {
		return nil
	}

	filename := fmt.Sprintf("products_page_%d_detailed.json", pageNumber)
	filepath := filepath.Join(j.outputDir, filename)

	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", filepath, err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	encoder.SetEscapeHTML(false)

	if err := encoder.Encode(products); err != nil {
		return fmt.Errorf("failed to encode products: %w", err)
	}

	return nil
}

// SaveFinalData saves all products to the final JSON file
func (j *JSONStorage) SaveFinalData(products []models.Product) error {
	if len(products) == 0 {
		return nil
	}

	filepath := filepath.Join(j.outputDir, "all_products_detailed.json")

	file, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create final file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	encoder.SetEscapeHTML(false)

	if err := encoder.Encode(products); err != nil {
		return fmt.Errorf("failed to encode final products: %w", err)
	}

	return nil
}

// ProductExists checks if a product exists in any of the JSON files
func (j *JSONStorage) ProductExists(productID string) (bool, error) {
	existingProducts, err := j.GetExistingProducts()
	if err != nil {
		return false, err
	}

	for _, id := range existingProducts {
		if id == productID {
			return true, nil
		}
	}

	return false, nil
}

// GetExistingProducts returns all product IDs from existing JSON files
func (j *JSONStorage) GetExistingProducts() ([]string, error) {
	var allIDs []string

	// –ß–∏—Ç–∞–µ–º –≤—Å–µ JSON —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
	files, err := filepath.Glob(filepath.Join(j.outputDir, "*.json"))
	if err != nil {
		return nil, fmt.Errorf("failed to glob JSON files: %w", err)
	}

	for _, file := range files {
		// –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ —Ñ–∞–π–ª—ã
		if strings.Contains(filepath.Base(file), "temp") {
			continue
		}

		products, err := j.readProductsFromFile(file)
		if err != nil {
			continue // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ–∞–π–ª—ã —Å –æ—à–∏–±–∫–∞–º–∏
		}

		for _, product := range products {
			allIDs = append(allIDs, product.ID)
		}
	}

	return allIDs, nil
}

// readProductsFromFile reads products from a specific JSON file
func (j *JSONStorage) readProductsFromFile(filePath string) ([]models.Product, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var products []models.Product
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&products); err != nil {
		return nil, err
	}

	return products, nil
}

// Close implements Storage interface (no-op for JSON)
func (j *JSONStorage) Close() error {
	return nil
}



================================================
FILE: pricerunner-parser/internal/storage/storage.go
================================================
package storage

import "pricerunner-parser/internal/models"

// Storage defines the interface for data storage
type Storage interface {
	// SaveProducts saves a slice of products
	SaveProducts(products []models.Product, pageNumber int) error

	// SaveFinalData saves all products to a final file/table
	SaveFinalData(products []models.Product) error

	// ProductExists checks if a product already exists
	ProductExists(productID string) (bool, error)

	// GetExistingProducts returns a list of existing product IDs
	GetExistingProducts() ([]string, error)

	// Close closes any open connections
	Close() error
}


